<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1"/>
        <link rel="icon" type="image/png" href="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPg0KPHN2ZyB3aWR0aD0iODAwcHgiIGhlaWdodD0iODAwcHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCjxwYXRoIGQ9Ik03LjkwNDUxIDYuOTIxNDRDOC40MTM0MSA2LjQ1NDk1IDguNDQ3NzkgNS42NjQyNCA3Ljk4MTMgNS4xNTUzNEM3LjUxNDgxIDQuNjQ2NDUgNi43MjQxIDQuNjEyMDcgNi4yMTUyIDUuMDc4NTZMNy45MDQ1MSA2LjkyMTQ0Wk0xLjQ2MTk0IDExLjEzMTRMMi4zMDY2IDEyLjA1MjlMMi4zMDY2IDEyLjA1MjlMMS40NjE5NCAxMS4xMzE0Wk0xLjQ2MTk0IDExLjg2ODZMMi4zMDY2IDEwLjk0NzFMMi4zMDY2IDEwLjk0NzFMMS40NjE5NCAxMS44Njg2Wk02LjIxNTIgMTcuOTIxNEM2LjcyNDEgMTguMzg3OSA3LjUxNDgxIDE4LjM1MzYgNy45ODEzIDE3Ljg0NDdDOC40NDc3OSAxNy4zMzU4IDguNDEzNDEgMTYuNTQ1IDcuOTA0NTEgMTYuMDc4Nkw2LjIxNTIgMTcuOTIxNFpNNi4yMTUyIDUuMDc4NTZMMC42MTcyODcgMTAuMjFMMi4zMDY2IDEyLjA1MjlMNy45MDQ1MSA2LjkyMTQ0TDYuMjE1MiA1LjA3ODU2Wk0wLjYxNzI4NyAxMi43OUw2LjIxNTIgMTcuOTIxNEw3LjkwNDUxIDE2LjA3ODZMMi4zMDY2IDEwLjk0NzFMMC42MTcyODcgMTIuNzlaTTAuNjE3Mjg3IDEwLjIxQy0wLjEzOTM1NiAxMC45MDM2IC0wLjEzOTM1NiAxMi4wOTY0IDAuNjE3Mjg3IDEyLjc5TDIuMzA2NiAxMC45NDcxQzIuNjMwODcgMTEuMjQ0NCAyLjYzMDg3IDExLjc1NTYgMi4zMDY2IDEyLjA1MjlMMC42MTcyODcgMTAuMjFaIiBmaWxsPSIjMDAwMDAwIi8+DQo8cGF0aCBkPSJNMTYuMDU1NyAxNi4wNzg2QzE1LjU0NjggMTYuNTQ1IDE1LjUxMjUgMTcuMzM1OCAxNS45Nzg5IDE3Ljg0NDdDMTYuNDQ1NCAxOC4zNTM2IDE3LjIzNjEgMTguMzg3OSAxNy43NDUgMTcuOTIxNEwxNi4wNTU3IDE2LjA3ODZaTTIyLjQ5ODMgMTEuODY4NkwyMS42NTM3IDEwLjk0NzFMMjEuNjUzNyAxMC45NDcxTDIyLjQ5ODMgMTEuODY4NlpNMjIuNDk4MyAxMS4xMzE0TDIxLjY1MzcgMTIuMDUyOUwyMS42NTM3IDEyLjA1MjlMMjIuNDk4MyAxMS4xMzE0Wk0xNy43NDUgNS4wNzg1NkMxNy4yMzYxIDQuNjEyMDcgMTYuNDQ1NCA0LjY0NjQ1IDE1Ljk3OSA1LjE1NTM0QzE1LjUxMjUgNS42NjQyNCAxNS41NDY4IDYuNDU0OTUgMTYuMDU1NyA2LjkyMTQ0TDE3Ljc0NSA1LjA3ODU2Wk0xNy43NDUgMTcuOTIxNEwyMy4zNDMgMTIuNzlMMjEuNjUzNyAxMC45NDcxTDE2LjA1NTcgMTYuMDc4NkwxNy43NDUgMTcuOTIxNFpNMjMuMzQzIDEwLjIxTDE3Ljc0NSA1LjA3ODU2TDE2LjA1NTcgNi45MjE0NEwyMS42NTM3IDEyLjA1MjlMMjMuMzQzIDEwLjIxWk0yMy4zNDMgMTIuNzlDMjQuMDk5NiAxMi4wOTY0IDI0LjA5OTYgMTAuOTAzNiAyMy4zNDMgMTAuMjFMMjEuNjUzNyAxMi4wNTI5QzIxLjMyOTQgMTEuNzU1NiAyMS4zMjk0IDExLjI0NDQgMjEuNjUzNyAxMC45NDcxTDIzLjM0MyAxMi43OVoiIGZpbGw9IiMwMDAwMDAiLz4NCjxwYXRoIGQ9Ik0xNS4yMTI3IDMuODAzMTdDMTUuMzgwMSAzLjEzMzQzIDE0Ljk3MjkgMi40NTQ3NiAxNC4zMDMyIDIuMjg3MzJDMTMuNjMzNCAyLjExOTg5IDEyLjk1NDggMi41MjcwOSAxMi43ODczIDMuMTk2ODNMMTUuMjEyNyAzLjgwMzE3Wk04Ljc4NzMyIDE5LjE5NjhDOC42MTk4OSAxOS44NjY2IDkuMDI3MDkgMjAuNTQ1MiA5LjY5NjgzIDIwLjcxMjdDMTAuMzY2NiAyMC44ODAxIDExLjA0NTIgMjAuNDcyOSAxMS4yMTI3IDE5LjgwMzJMOC43ODczMiAxOS4xOTY4Wk0xMi43ODczIDMuMTk2ODNMOC43ODczMiAxOS4xOTY4TDExLjIxMjcgMTkuODAzMkwxNS4yMTI3IDMuODAzMTdMMTIuNzg3MyAzLjE5NjgzWiIgZmlsbD0iIzAwMDAwMCIvPg0KPC9zdmc+">
        <title>varcraft</title>
    </head>
    <body>
        <script type="module">

document.body.style.margin = 0

const mk = (id, target, tag = 'div') => {
  const el = document.createElement(tag)
  if (id) {
    if (id[0] === '.') {
      el.className = id.slice(1)
    } else {
      el.id = id
    }
  }
  target.append(el)
  return el
}

//LOAD FONTS
{
  const fontUrl = 'https://fonts.googleapis.com/css2?family';
  [
    `${fontUrl}=Roboto:wght@400;700&display=swap`,
    `${fontUrl}=JetBrains+Mono:wght@400;700&display=swap`
  ].forEach(url => {
    const link = mk(null, document.head, 'link')
    link.rel = 'stylesheet'
    link.href = url
  })
}

//LOAD MONACO EDITOR
{
  const { promise: editorIsReady, resolve: editorIsReadyResolve } = Promise.withResolvers()
  const requireScript = document.createElement('script');
  requireScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js'
  requireScript.onload = () => {
      require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs' } })
      require(['vs/editor/editor.main'], editorIsReadyResolve)
  }
  document.head.append(requireScript)
  await editorIsReady
}


const app = mk('app', document.body)
app.style.display = 'flex'

const obWidth = 250
const obPadding = 8
let ob = mk('object-browser', app)
ob.style.width = obWidth + 'px'
ob.style.height = window.innerHeight - obPadding * 2 + 'px'
ob.style.padding = obPadding + 'px'

ob = ob.attachShadow({mode: 'open'})
const style = mk(0, ob, 'style')
style.textContent = `
  :host {
    display: block;
    background: #f3f3f3;
    color: #616161;
    font-family: Roboto, monospace;
  }
  .ob-section {
    margin-bottom: 0.5em;
  }
  .object-browser-header {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .op-list-btn {
    width: 24px;
    height: 24px;
    cursor: pointer;
  }
  .object {
    cursor: pointer;
  }
  .object:hover:not(:has(.object:hover)) {
    background:rgb(229, 229, 229);
  }
  .children {
    margin-left: 1em;
  }
`

const obHeader = mk('.object-browser-header', ob)
mk(0, ob, 'br')

const readFileFromInput = async (fileInput) => {
  const { promise, resolve, reject } = Promise.withResolvers()  
  const r = new FileReader()
  r.readAsText(fileInput)
  r.onload = async () => resolve(r.result)
  r.onerror = reject
  return promise
}
const importDump = async (db, objects) => {
  for (const storeName in objects) {
    const store = objects[storeName]
    
    if (Array.isArray(store)) {
      for (const object of store) {
        await db.set({ storeName, id: object.id, value: object })
      }
    } else {
      for (const key in store) {
        await db.set({ storeName, id: key, value: store[key] })
      }
    }
  }
}

const importDumpFromUrl = async (db, url) => await importDump(db, await (await fetch(url)).json())

const exportDump = async (db, storeNames = [], dumpName) => {
  const dump = {}

  for (const storeName of storeNames) {
    if (storeName === 'kv') {
      const o = {}
      const keys = await db.getKeys({ storeName })
      for (const key of keys) {
        o[key] = await db.get({ storeName, id: key })
      }
      dump[storeName] = o
    } else {
      dump[storeName] = await db.getAll({ storeName })
    }
  }

  const blob = new Blob([JSON.stringify(dump)], { type: 'application/json' })
  const a = document.createElement('a')
  a.href = URL.createObjectURL(blob)
  a.download = dumpName || 'dump.json'
  a.click()
  URL.revokeObjectURL(a.href)
}

const opListManager = {
  opList: null,
  createOpList() {
    if (this.opList) {
      this.removeOpList()
      return
    }
    this.opList = mk('.op-list', app)
    const style = mk(null, this.opList, 'style')
    style.innerHTML = `
      .op-list {
        min-width: 10em;
        position: absolute;
        background: #f3f3f3;
        color: #616161;
        font-family: Roboto, sans-serif;
        box-shadow: rgba(2, 0, 0, 0.35) 0px 5px 15px;
        cursor: pointer;
        z-index: 1000;
      }
      .op-list-item {
        padding: 5px;
      }
        .op-list-item:hover {
        background:rgb(221, 221, 221);
      }          
    `
    return this.opList
  },
  removeOpList() {
    this.opList.remove()
    this.opList = null
  }
}

//OP LIST BUTTON, BURGER MENU
{
  const opListBtn = mk('.op-list-btn', obHeader)
  opListBtn.innerHTML = `
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="size-6">
    <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
    </svg>
  `

  const opListBtnRect = opListBtn.getBoundingClientRect()

  opListBtn.addEventListener('click', (e) => {
    const opList = opListManager.createOpList()
    if (!opList) return

    opList.style.left = `${opListBtnRect.left}px`
    opList.style.top = `${opListBtnRect.top + opListBtnRect.height}px`

    const itemSystemImport = mk('.op-list-item', opList)
    itemSystemImport.textContent = 'Import system objects'

    let fInput = mk(null, itemSystemImport, 'input')
    fInput.type = 'file'
    fInput.style.marginLeft = '10px'
    fInput.addEventListener('change', async(e) => {
      importDump(dbSys, JSON.parse(await readFileFromInput(e.target.files[0])))
    })

    const itemSystemExport = mk('.op-list-item', opList)
    itemSystemExport.textContent = 'Export system objects'
    itemSystemExport.addEventListener('click', async () => {
      exportDump(dbSys, ['objects'], 'dump.json')
    })

    const itemUserImport = mk('.op-list-item', opList)
    itemUserImport.textContent = 'Import user objects'

    fInput = mk(null, itemUserImport, 'input')
    fInput.type = 'file'
    fInput.style.marginLeft = '10px'
    fInput.addEventListener('change', async (e) => {
      importDump(dbUser, JSON.parse(await readFileFromInput(e.target.files[0])))
    })

    const itemUserExport = mk('.op-list-item', opList)
    itemUserExport.textContent = 'Export user objects'
    itemUserExport.addEventListener('click', (e) => {
      e.preventDefault()
      exportDump(dbUser, ['objects', 'kv'], 'user-dump.json')
    })
  })
}

const createSectionOpList = (repo, target, e) => {
  e.preventDefault()

  const opList = opListManager.createOpList()
  if (!opList) return
  opList.style.left = `${e.clientX}px`
  opList.style.top = `${e.clientY}px`

  const mkOp = (txt) => {
    let i = mk(null, opList)
    i.className = 'op-list-item'
    i.textContent = txt
    return i
  }
  mkOp('New Code Object').addEventListener('click', async (e) => {
    opListManager.removeOpList()
    const newObject = objectCreator.createCodeObject()

    const children = target.getElementsByClassName('children')[0]
    if (!children) return
    if (!children.children.length) {
      await repo.setObject(newObject.id, newObject)
      renderObjectName(newObject, children, repo)
      return
    }
    createNewObject(target, repo, newObject)
  })
  mkOp('New Category Object').addEventListener('click', async (e) => {
    opListManager.removeOpList()
    const newObject = objectCreator.createCategoryObject()

    const children = target.getElementsByClassName('children')[0]
    if (!children) return
    if (!children.children.length) {
      await repo.setObject(newObject.id, newObject)
      renderObjectName(newObject, children, repo)
      return
    }
    createNewObject(target, repo, newObject)
  })
}

const obHeading = mk(0, obHeader)
obHeading.textContent = 'EXPLORER'


//SYSTEM SECTION
{
  ob.systemSection = mk('ob-system-section', ob)
  ob.systemSection.className = 'ob-section'

  const heading = mk(0, ob.systemSection)
  heading.textContent = 'System:'
  heading.style.fontWeight = 'bold'
  heading.style.cursor = 'pointer'
  heading.addEventListener('contextmenu', (e) => {
    createSectionOpList(systemObjectsRepository, ob.systemSection, e)
  })
  ob.systemSection.childrenDiv = mk(0, ob.systemSection)
  ob.systemSection.childrenDiv.className = 'children'
}

//USER SECTION
{
  ob.userSection = mk('ob-user-section', ob)
  ob.userSection.className = 'ob-section'

  const heading = mk(0, ob.userSection)
  heading.textContent = 'User:'
  heading.style.fontWeight = 'bold'
  heading.style.cursor = 'pointer'
  heading.addEventListener('contextmenu', (e) => {
    createSectionOpList(userObjectsRepository, ob.userSection, e)
  })

  ob.userSection.childrenDiv = mk(0, ob.userSection)
  ob.userSection.childrenDiv.className = 'children'
}

const ulid = (() => {
  const ENCODING = '0123456789ABCDEFGHJKMNPQRSTVWXYZ';
  const ENCODING_LEN = ENCODING.length;
  const TIME_LEN = 10;
  const RANDOM_LEN = 16;
  const TIME_MAX = Math.pow(2, 48) - 1;

  let lastTime = 0;
  let lastRandom = '';

  function getPRNG(allowInsecure) {
    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
      return () => {
        const buf = new Uint8Array(1);
        crypto.getRandomValues(buf);
        return buf[0] / 0xff;
      };
    }
    if (allowInsecure) {
      return () => Math.random();
    }
    throw new Error('secure crypto unavailable');
  }

  function randChar(rng) {
    let r = Math.floor(rng() * ENCODING_LEN);
    if (r === ENCODING_LEN) r = ENCODING_LEN - 1;
    return ENCODING[r];
  }

  function encodeTime(ms) {
    if (!Number.isInteger(ms) || ms < 0 || ms > TIME_MAX) {
      throw new Error('invalid time');
    }
    let str = '';
    for (let i = 0; i < TIME_LEN; i++) {
      str = ENCODING[ms % ENCODING_LEN] + str;
      ms = Math.floor(ms / ENCODING_LEN);
    }
    return str;
  }

  function encodeRandom(rng) {
    let str = '';
    for (let i = 0; i < RANDOM_LEN; i++) {
      str = randChar(rng) + str;
    }
    return str;
  }

  function increment(str) {
    const arr = str.split('');
    for (let i = arr.length - 1; i >= 0; i--) {
      const idx = ENCODING.indexOf(arr[i]);
      if (idx < 0) throw new Error('invalid random component');
      if (idx < ENCODING_LEN - 1) {
        arr[i] = ENCODING[idx + 1];
        return arr.join('');
      }
      arr[i] = ENCODING[0];
    }
    throw new Error('cannot increment');
  }

  return function({ monotonic = false, allowInsecure = false, prng, time } = {}) {
    const ms = Number.isInteger(time) ? time : Date.now();
    const rng = prng || getPRNG(allowInsecure);

    if (monotonic) {
      if (ms <= lastTime) {
        lastRandom = increment(lastRandom);
      } else {
        lastTime = ms;
        lastRandom = encodeRandom(rng);
      }
      return encodeTime(lastTime) + lastRandom;
    }

    return encodeTime(ms) + encodeRandom(rng);
  };
})();

//Base >> viewManager
//tabManager
//windowsManager
const createTabManager = (target, mk, width) => {

  const tabsContainer = mk('tabs-container', target)
  tabsContainer.style.width = width
  const style = mk(null, tabsContainer, 'style')
  style.innerHTML = `
    #tabs-bar {
      display: flex;
      background: #f3f3f3;
    }
    .tab {
      display: flex;
      align-items: center;
      padding: 8px;
      cursor: pointer;
      background: #e4e4e4;
    }
    .tab.active {
      background: #FFFFFF;
    }
    .tab-name {
      font-family: Roboto, sans-serif;
      margin-right: 3px;
      color: #333333;
    }
    .tab-view.hidden {
      display: none;
    } 
    .object-code {
      font-family: 'JetBrains Mono', monospace;
    }
    #close-tab-btn {
      width: 18px;
      height: 18px;
      stroke: currentColor;
    }
  `
  
  const tabsBar = mk('tabs-bar', tabsContainer)
  const tabsBarHeight = 35
  const tabsView = mk('tabs-view', tabsContainer)
  tabsView.style.height = window.innerHeight - tabsBarHeight + 'px' 
  tabsView.style.overflow = 'scroll'

  let activeTab

  const openTab = (repo, object) => {

    const tab = mk(null, tabsBar)
    tab.className = 'tab active'
    tab.setAttribute('object-id', object.id)
    tab.addEventListener('click', () => {
      console.log('click', tab)
      activateTab(tab)
      saveActiveTab(object.id)
    })

    tab.name = mk(null, tab)
    tab.name.className = 'tab-name'
    tab.name.textContent = object.data.name
    
    tab.closeBtn = mk('close-tab-btn', tab)
    tab.closeBtn.addEventListener('click', (e) => {
      e.stopPropagation()

      let nextTab

      if (tab === activeTab) {
        const tabs = tabsBar.children
        const tabIndex = Array.from(tabs).indexOf(tab)
        
        nextTab = tabIndex > 0 
          ? tabs[tabIndex - 1]
          : tabs[tabIndex + 1];
      }

      closeTab(tab)
      //todo add second param as source which opened object before, in this case it's tabManager
      objectsManager.closeObject(object, 'tabManager')

      if (nextTab) {
        activateTab(nextTab)
        saveActiveTab(nextTab.getAttribute('object-id'))
      } else {
        console.warn('No next tab found')
        clearActiveTab()
      }
    })
    tab.closeBtn.innerHTML += `
      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-6">
        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12"></path>
      </svg>
    `
    tab.view = mk('.tab-view', tabsView)

    const pre = mk('object-code', tab.view, 'div')
    pre.style.height = window.innerHeight - tabsBarHeight + 'px' 
    const editor = monaco.editor.create(pre, {
      value: object.data.code, 
      language: 'javascript',
      theme: 'vs-dark', 
      automaticLayout: true, 
      fontSize: 15
    })
    
    const openedObjects = objectsManager.getOpenedObjects()
    const pos = openedObjects[object.id]
    if (pos && typeof pos === 'object') editor.revealPositionInCenter(pos)

    editor.onDidChangeModelContent((e) => {
      if (!object.id) return
      
      const pos = editor.getPosition()
      objectsManager.openObject(object, pos)
      object.data.code = editor.getValue()

      repo.setObject(object.id, object)
    })

    activateTab(tab)
  }
  const closeTab = (tab) => {
    tab.remove()
    tab.view.remove()
  }
  const activateTab = (tab) => {
    if (activeTab) {
      activeTab.classList.remove('active')
      activeTab.view.classList.add('hidden')
    }
    tab.classList.add('active')
    tab.view.classList.remove('hidden')
    activeTab = tab
  }
  const saveActiveTab = (id) => kvRepository.setKey('activeTabId', id)
  const clearActiveTab = () => kvRepository.delKey('activeTabId')
  const restoreLastActiveTab = async () => {
    const value = await kvRepository.getKey('activeTabId')
    if (!value) return

    const tab = tabsBar.querySelector(`[object-id="${value}"]`)
    activateTab(tab)
  }

  return { openTab, saveActiveTab, restoreLastActiveTab }
}

const tabManagerWidth = `calc(100% - ${obWidth + obPadding * 2}px)`
const tabManager = createTabManager(app, mk, tabManagerWidth)
//const objectsView = mk('objects-view', app)

class IndexedDb {  
  async open(dbName = 'default', storages = ['default']) {
    return new Promise((resolve, reject) => {
      const openRequest = indexedDB.open(dbName)
      
      openRequest.onerror = () => {
        reject(openRequest.error)
      }
      openRequest.onsuccess = () => {
        this.db = openRequest.result
        resolve(this.db)
      }
      openRequest.onupgradeneeded = () => {
        const db = openRequest.result
        
        for (const storageName of storages) {
          if (!db.objectStoreNames.contains(storageName)) {
            db.createObjectStore(storageName)
          }
        }
      }
    })
  }
  async set(x) {
    const { storeName = 'default', id, value } = x

    return new Promise((resolve, reject) => {
      const rq = this.db.transaction(storeName, 'readwrite').objectStore(storeName).put(value, id)
      rq.onsuccess = () => resolve(rq.result)
      rq.onerror = () => reject(rq.error)
    })
  }
  async get(x) {
    const { storeName = 'default', id } = x

    return new Promise((resolve, reject) => {
      const rq = this.db.transaction(storeName, 'readonly').objectStore(storeName).get(id)
      rq.onsuccess = () => resolve(rq.result)
      rq.onerror = () => reject(rq.error)
    })
  }
  async getAll(x) {
    const { storeName = 'default' } = x
    return new Promise((resolve, reject) => {
      const rq = this.db.transaction(storeName, 'readonly').objectStore(storeName).getAll()
      rq.onsuccess = () => resolve(rq.result)
      rq.onerror = () => reject(rq.error)
    })
  }
  async getKeys(x) {
    const { storeName = 'default' } = x
    return new Promise((resolve, reject) => {
      const rq = this.db.transaction(storeName, 'readonly').objectStore(storeName).getAllKeys()
      rq.onsuccess = () => resolve(rq.result)
      rq.onerror = () => reject(rq.error)
    })
  }
  async del(x) {
    const { storeName = 'default', id } = x

    return new Promise((resolve, reject) => {
      const rq = this.db.transaction(storeName, 'readwrite').objectStore(storeName).delete(id)
      rq.onsuccess = () => resolve(rq.result)
      rq.onerror = () => reject(rq.error)
    })
  }
}

const dbSys = new IndexedDb
await dbSys.open('sys', ['objects'])
const dbUser = new IndexedDb
await dbUser.open('user', ['objects', 'kv'])

const baseRepository = {
  db: null,
  table: null,
  init(db) { 
    this.db = db
  },
  async getById(id) {
    return await this.db.get({ storeName: this.table, id })
  },
}

const createRepository = (child) => Object.assign(Object.create(baseRepository), child)

const createObjectsRepository = (child = {}) => createRepository({
  table: 'objects',
  async getAll() {
    return await this.db.getAll({ storeName: this.table })
  },
  async setObject(id, object) { 
    await this.db.set({ storeName: this.table, id, value: object }) 
  },
  async updateObjectData(objectId, data) {
    await this.db.query(`UPDATE public.${this.table} SET data = $1 WHERE id = $2`, [data, objectId])
  },
  async getNextObjects(objectId) {
    const object = await this.db.get({ storeName: this.table, id: objectId })
    if (!object || !object.next_id) return []
    
    const objects = []

    let currentId = object.next_id
    while (currentId) {
      const object = await this.db.get({ storeName: this.table, id: currentId })
      if (!object) { 
        console.warn(`No record found with id=${currentId}`)
        break
      }
      objects.push(object)
      currentId = object.next_id
    }
    return objects
  },
  async del(id) {
    await this.db.del({ storeName: this.table, id })
  },

  ...child
})

const systemObjectsRepository = createObjectsRepository()
systemObjectsRepository.init(dbSys)
const userObjectsRepository = createObjectsRepository()
userObjectsRepository.init(dbUser)

const kvRepository = createRepository({
  table: 'kv',
  async getKey(key) {
    return await this.db.get({ storeName: this.table, id: key })
  },
  async setKey(key, value) {
    await this.db.set({ storeName: this.table, id: key, value })
  },
  async delKey(key) {
    await this.db.del({ storeName: this.table, id: key })
  }
})
kvRepository.init(dbUser)

const objectCreator = {
  createMainObject(prefix) {
    return {
      id: `${prefix}-main`,
      data: { name: `${prefix}-main`, code: 'const { object } = $' },
    }
  },
  createCodeObject() {
    return {
      id: ulid(),
      data: { name: 'new code object', code: 'const { object } = $' },
    }
  },
  createCategoryObject() {
    return {
      id: ulid(),
      data: { name: 'new category object' },
    }
  }
}

const objectsManager = {
  openedObjectsIds: {},
  async init() {
    const v = await kvRepository.getKey('openedObjectsIds')
    if (v) this.openedObjectsIds = v
  },
  getOpenedObjects() {
    return this.openedObjectsIds
  },
  isObjectOpened(objectId) {
    return Boolean(this.openedObjectsIds[objectId])
  },
  openObject(object, pos) {
    this.openedObjectsIds[object.id] = pos ? pos : 1
    this.saveOpenedObjects()
  },
  openObjectWithObject(object, otherObject) {},
  closeObject(object) {
    delete this.openedObjectsIds[object.id]
    this.saveOpenedObjects()
  },
  saveOpenedObjects() {
    kvRepository.setKey('openedObjectsIds', this.openedObjectsIds)
  },
}
await objectsManager.init()

const createNewObject = async (dom, repo, newObject) => {

  const children = dom.getElementsByClassName('children')[0]
  if (children && children.children.length) {
    const last = children.children[children.children.length - 1]
    const lastObject = await repo.getById(last.id)

    lastObject.next_id = newObject.id
    newObject.prev_id = last.id

    await Promise.all([
      repo.setObject(lastObject.id, lastObject),
      repo.setObject(newObject.id, newObject),
    ])
  } else {
    const parentObject = await repo.getById(dom.id)
    if (!parentObject) { console.warn(`No parent object found with id=${dom.id}`); return; }

    parentObject.child_id = newObject.id
    newObject.parent_id = parentObject.id

    await Promise.all([
      repo.setObject(parentObject.id, parentObject),
      repo.setObject(newObject.id, newObject),
    ])
  }
    
  renderObjectName(newObject, children, repo)
}


const renderObjectName = (object, target, repo) => {
  const dom = mk(object.id, target)
  dom.className = 'object'
  dom.name = mk(null, dom)
  dom.name.innerText = object.data.name
  dom.name.addEventListener('click', async (e) => {
    if (objectsManager.isObjectOpened(object.id)) return
    tabManager.openTab(repo, object)
    tabManager.saveActiveTab(object.id)
    objectsManager.openObject(object)
  })
  dom.name.addEventListener('contextmenu', (e) => {
    e.preventDefault()
    e.stopPropagation()

    const opList = opListManager.createOpList()
    if (!opList) return
    opList.style.left = `${e.clientX}px`
    opList.style.top = `${e.clientY}px`

    const mkOp = (text) => {
      let i = mk(null, opList)
      i.className = 'op-list-item'
      i.textContent = text
      return i
    }

    mkOp('New Code Object').addEventListener('click', async (e) => {
      opListManager.removeOpList()
      createNewObject(dom, repo, objectCreator.createCodeObject())
    })
    mkOp('New Category Object').addEventListener('click', async (e) => {
      opListManager.removeOpList()
      createNewObject(dom, repo, objectCreator.createCategoryObject())
    })
    mkOp('Info').addEventListener('click', () => {
      opListManager.removeOpList()
      console.log(object)
    })
    mkOp('Rename').addEventListener('click', () => {
      opListManager.removeOpList()
      dom.name.contentEditable = true
      dom.name.focus()

      const originalName = dom.name.textContent
      const handleRename = async () => {
        dom.name.contentEditable = false
        const newName = dom.name.textContent.trim()
        if (!newName || newName === originalName) {
            dom.name.textContent = originalName
            return
        }
        object.data.name = newName
        await repo.setObject(object.id, object)
      }

      const onKeyDown = async (e) => {
        if (e.key === 'Enter') {
          e.preventDefault()
          await handleRename()
          dom.name.removeEventListener('keydown', onKeyDown)
        }
        if (e.key === 'Escape') {
          dom.name.contentEditable = false
          dom.name.textContent = originalName
          dom.name.removeEventListener('keydown', onKeyDown)
        }
      }

      dom.name.addEventListener('keydown', onKeyDown)
    })
    mkOp('Delete').addEventListener('click', async () => {
      opListManager.removeOpList()

      const childObject = object.child_id ? await repo.getById(object.child_id) : null
      if (childObject) {
        alert('Please delete all child objects first before deleting this object')
        return
      }

      const prevObject = object.prev_id ? await repo.getById(object.prev_id) : null
      const nextObject = object.next_id ? await repo.getById(object.next_id) : null
      const parentObject = object.parent_id ? await repo.getById(object.parent_id) : null

      if (parentObject) {
        parentObject.child_id = nextObject ? nextObject.id : null
        await repo.setObject(parentObject.id, parentObject)
      }

      if (prevObject && nextObject) {
        prevObject.next_id = nextObject.id
        await repo.setObject(prevObject.id, prevObject)
        
        nextObject.prev_id = prevObject.id
        await repo.setObject(nextObject.id, nextObject)

      } else if (prevObject) {
        prevObject.next_id = null
        await repo.setObject(prevObject.id, prevObject)

      } else if (nextObject) {
        nextObject.prev_id = null
        await repo.setObject(nextObject.id, nextObject)
      }

      await repo.del(object.id)
      dom.remove()

      //todo delete from openedObjectsIds
      //from active tab id, or check active tab id if exists such object
    })
  })

  const children = mk(null, dom)
  children.className = 'children'

  return { objectDom: dom, children }
}
const runObjectCode = async (x) => {
  const { object, objectBrowser, objectsManager, tabManager, 
    renderObjectName, systemObjectsRepository, userObjectsRepository } = x
  const code = `export default async ($) => { 
    ${object.data.code}
  }`
  const blob = new Blob([code], { type: 'application/javascript' })
  try {
    const m = (await import(URL.createObjectURL(blob)))
    m.default({ 
      o: object, objectBrowser, objectsManager, tabManager, renderObjectName, 
      systemObjectsRepository, userObjectsRepository
    })
  } catch (e) {
    console.error(e)
  }
}

let sysMainObject = await systemObjectsRepository.getById('sys-main')
if (!sysMainObject) {
    await importDumpFromUrl(dbSys, '/dump.json')
    sysMainObject = await systemObjectsRepository.getById('sys-main')
}
const openedObjects = await objectsManager.getOpenedObjects()
const isSysMainFound = Object.keys(openedObjects).find(id => id.trim() === 'sys-main')
if (isSysMainFound) tabManager.openTab(systemObjectsRepository, sysMainObject)

let userMainObject = await userObjectsRepository.getById('user-main')
if (!userMainObject) {
  userMainObject = objectCreator.createMainObject('user')
  await userObjectsRepository.setObject(userMainObject.id, userMainObject)
}

await renderObjectName(sysMainObject, ob.systemSection.childrenDiv, systemObjectsRepository)
await runObjectCode({
  object: sysMainObject, 
  objectBrowser: ob,
  objectsManager, tabManager, renderObjectName,
  systemObjectsRepository, userObjectsRepository
})

        </script>
    </body>
</html>