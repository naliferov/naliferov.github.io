{"objects":[{"id":"01JS94VDYB2W12XJDWGVCGQ4C4","data":{"name":"psbus","code":"const psbus = () => {\n\n  const createDataProxy = (data, x) => new Proxy(() => {}, {\n    get(target, prop) {\n      if (prop === 'p') return (...args) => x.p(...args)\n      if (prop === 's') return (...args) => { x.s(...args); return x; }\n      if (prop === 'toJSON') return () => data\n      return data[prop]\n    },\n    set(target, prop, value) {\n      data[prop] = value\n      return true\n    },\n  })\n\n  const x = {\n    events: {},\n    func: {},\n\n    async p(event, data = {}) {\n      const dataObject = typeof data === 'function' ? data : createDataProxy(data, x)\n      const func = this.func[event]\n\n      if (!func) {\n        const events = this.events\n        if (!events[event]) events[event] = []\n\n        const { promise, resolve } = Promise.withResolvers()\n        events[event].push({ data, resolve })\n        console.log(`deferred event [${event}]`)\n        return promise\n      }\n\n      if (typeof func !== 'function') console.log(event, func);\n      return func(dataObject);\n    },\n\n    async s(event, func) {\n      this.func[event] = func;\n      const events = this.events[event];\n      if (!events) return this;\n\n      console.log(`executed deferred event > [${event}]`);\n      for (const { data, resolve } of events) {\n        const response = await this.p(event, data);\n        resolve(response);\n      }\n\n      delete this.events[event];\n      return this;\n    },\n  };\n\n  return x\n}\n\nreturn psbus()"}},{"id":"01JT309AEK97K1ZV8BG6933ASB","data":{"name":"ulid","code":"const ulid = (() => {\n  const ENCODING = '0123456789ABCDEFGHJKMNPQRSTVWXYZ';\n  const ENCODING_LEN = ENCODING.length;\n  const TIME_LEN = 10;\n  const RANDOM_LEN = 16;\n  const TIME_MAX = Math.pow(2, 48) - 1;\n\n  let lastTime = 0;\n  let lastRandom = '';\n\n  function getPRNG(allowInsecure) {\n    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n      return () => {\n        const buf = new Uint8Array(1);\n        crypto.getRandomValues(buf);\n        return buf[0] / 0xff;\n      };\n    }\n    if (allowInsecure) return () => Math.random();\n    throw new Error('secure crypto unavailable');\n  }\n\n  function randChar(rng) {\n    let r = Math.floor(rng() * ENCODING_LEN);\n    if (r === ENCODING_LEN) r = ENCODING_LEN - 1;\n    return ENCODING[r];\n  }\n\n  function encodeTime(ms) {\n    if (!Number.isInteger(ms) || ms < 0 || ms > TIME_MAX) {\n      throw new Error('invalid time');\n    }\n    let str = '';\n    for (let i = 0; i < TIME_LEN; i++) {\n      str = ENCODING[ms % ENCODING_LEN] + str;\n      ms = Math.floor(ms / ENCODING_LEN);\n    }\n    return str;\n  }\n\n  function encodeRandom(rng) {\n    let str = '';\n    for (let i = 0; i < RANDOM_LEN; i++) {\n      str = randChar(rng) + str;\n    }\n    return str;\n  }\n\n  function increment(str) {\n    const arr = str.split('');\n    for (let i = arr.length - 1; i >= 0; i--) {\n      const idx = ENCODING.indexOf(arr[i]);\n      if (idx < 0) throw new Error('invalid random component');\n      if (idx < ENCODING_LEN - 1) {\n        arr[i] = ENCODING[idx + 1];\n        return arr.join('');\n      }\n      arr[i] = ENCODING[0];\n    }\n    throw new Error('cannot increment');\n  }\n\n  return function ({ monotonic = false, allowInsecure = false, prng, time } = {}) {\n    const ms = Number.isInteger(time) ? time : Date.now();\n    const rng = prng || getPRNG(allowInsecure);\n\n    if (monotonic) {\n      if (ms <= lastTime) {\n        lastRandom = increment(lastRandom);\n      } else {\n        lastTime = ms;\n        lastRandom = encodeRandom(rng);\n      }\n      return encodeTime(lastTime) + lastRandom;\n    }\n\n    return encodeTime(ms) + encodeRandom(rng);\n  }\n})()\n\nreturn ulid()"}},{"id":"01JX5CFPJY0HTSHWY4Q87QMXJ1","data":{"name":"archive","code":"// input.addEventListener('change', event => {\n//     const file = event.target.files[0]\n//     if (!file) return\n//     const r = new FileReader()\n//     r.readAsArrayBuffer(file)\n//     r.onload = async () => {\n//         const arrBuf = r.result\n//         const data = { bin: r.result, binMeta: { name: file.name } }\n//     }\n// })"}},{"id":"sys-main","data":{"code":"class IndexedDb {  \n  async open(dbName = 'default', storages = ['default']) {\n    return new Promise((resolve, reject) => {\n      const openRequest = indexedDB.open(dbName)\n      \n      openRequest.onerror = () => {\n        reject(openRequest.error)\n      }\n      openRequest.onsuccess = () => {\n        this.db = openRequest.result\n        resolve(this.db)\n      }\n      openRequest.onupgradeneeded = () => {\n        const db = openRequest.result\n        \n        for (const storageName of storages) {\n          if (!db.objectStoreNames.contains(storageName)) {\n            db.createObjectStore(storageName)\n          }\n        }\n      }\n    })\n  }\n  async set(x) {\n    const { storeName = 'default', id, value } = x\n\n    return new Promise((resolve, reject) => {\n      const rq = this.db.transaction(storeName, 'readwrite').objectStore(storeName).put(value, id)\n      rq.onsuccess = () => resolve(rq.result)\n      rq.onerror = () => reject(rq.error)\n    })\n  }\n  async get(x) {\n    const { storeName = 'default', id } = x\n\n    return new Promise((resolve, reject) => {\n      const rq = this.db.transaction(storeName, 'readonly').objectStore(storeName).get(id)\n      rq.onsuccess = () => resolve(rq.result)\n      rq.onerror = () => reject(rq.error)\n    })\n  }\n  async getAll(x) {\n    const { storeName = 'default' } = x\n    return new Promise((resolve, reject) => {\n      const rq = this.db.transaction(storeName, 'readonly').objectStore(storeName).getAll()\n      rq.onsuccess = () => resolve(rq.result)\n      rq.onerror = () => reject(rq.error)\n    })\n  }\n  async getKeys(x) {\n    const { storeName = 'default' } = x\n    return new Promise((resolve, reject) => {\n      const rq = this.db.transaction(storeName, 'readonly').objectStore(storeName).getAllKeys()\n      rq.onsuccess = () => resolve(rq.result)\n      rq.onerror = () => reject(rq.error)\n    })\n  }\n  async del(x) {\n    const { storeName = 'default', id } = x\n\n    return new Promise((resolve, reject) => {\n      const rq = this.db.transaction(storeName, 'readwrite').objectStore(storeName).delete(id)\n      rq.onsuccess = () => resolve(rq.result)\n      rq.onerror = () => reject(rq.error)\n    })\n  }\n}\n\nclass BaseRepo {\n  db = null\n  table = null\n  init(db) { \n    this.db = db\n  }\n  async get(id) {\n    return await this.db.get({ storeName: this.table, id })\n  }\n  async getAll() {\n    return await this.db.getAll({ storeName: this.table })\n  }\n  async set(id, object) {\n      await this.db.set({ storeName: this.table, id, value: object }) \n  }\n  async del(id) {\n    await this.db.del({ storeName: this.table, id })\n  }\n}\nclass ObjectsRepository extends BaseRepo { table = 'objects' }\nclass KvRepo extends BaseRepo {\n  table = 'kv'\n  async get(key) {\n    return await this.db.get({ storeName: this.table, id: key })\n  }\n  async set(key, value) {\n    await this.db.set({ storeName: this.table, id: key, value })\n  }\n  async del(key) {\n    await this.db.del({ storeName: this.table, id: key })\n  }\n}\n\nconst dbSys = new IndexedDb\nawait dbSys.open('sys', ['objects'])\nconst dbUser = new IndexedDb\nawait dbUser.open('user', ['objects', 'kv'])\n\nconst sysObjectsRepo = new ObjectsRepository\nsysObjectsRepo.init(dbSys)\n\nconst userObjectsRepo = new ObjectsRepository\nuserObjectsRepo.init(dbUser)\n\nconst kvRepo = new KvRepo\nkvRepo.init(dbUser)\n\nconst mk = (id, target, tag = 'div') => {\n  const el = document.createElement(tag)\n  if (id) {\n    if (id[0] === '.') {\n      el.className = id.slice(1)\n    } else {\n      el.id = id\n    }\n  }\n  target.append(el)\n  return el\n}\n\nconst createFnFromCode = async (codeStr) => {\n  const code = `export default async ($) => { \n    ${codeStr} \n  }`\n  const blob = new Blob([code], { type: 'application/javascript' })\n  return (await import(URL.createObjectURL(blob))).default\n}\n\n//LOAD FONTS\n{\n  const fontUrl = 'https://fonts.googleapis.com/css2?family';\n  [\n    `${fontUrl}=Roboto:wght@400;700&display=swap`,\n    `${fontUrl}=JetBrains+Mono:wght@400;700&display=swap`\n  ].forEach(url => {\n    const link = mk(null, document.head, 'link')\n    link.rel = 'stylesheet'\n    link.href = url\n  })\n}\n\n//LOAD MONACO EDITOR\n{\n  const { promise: editorIsReady, resolve: editorIsReadyResolve } = Promise.withResolvers()\n  const requireScript = document.createElement('script');\n  requireScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js'\n  requireScript.onload = () => {\n      require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs' } })\n      require(['vs/editor/editor.main'], editorIsReadyResolve)\n  }\n  document.head.append(requireScript)\n  await editorIsReady\n}\n\ndocument.body.style.margin = 0\nconst app = mk('app', document.body)\napp.style.display = 'flex'\n\nwindow.moverInput = (e) => {\n  e.preventDefault()\n  const t = e.target\n  const p = t.parentNode\n  const k = e.key\n\n  let step = parseInt(t.value, 10)\n  let stepAtt = parseInt(t.getAttribute('value'), 10)\n  \n  if (step && stepAtt && step !== stepAtt) {\n      t.setAttribute('value', step)\n  } else if (!step) {\n      step = stepAtt || 20\n      t.setAttribute('value', step)\n  }\n  \n  const getCordNum = (str) => parseInt(str.slice(0, -2), 10)\n\n  if (k === 'ArrowLeft') {\n    let left = getCordNum(p.style.left)\n    if (left) {\n      const newLeft = left - step; if (newLeft <= 0) return;\n      p.style.left = newLeft + 'px'\n    }\n  }\n  if (k === 'ArrowRight') {\n    let left = getCordNum(p.style.left)\n    if (left) p.style.left = left + step + 'px'\n  }\n  if (k === 'ArrowUp') {\n    let top = getCordNum(p.style.top)\n    if (top) {\n      const newTop = top - step; if (newTop <= 0) return;\n      p.style.top = newTop + 'px'\n    }\n  }\n  if (k === 'ArrowDown') {\n    let top = getCordNum(p.style.top)\n    if (top) p.style.top = top + step + 'px'\n  }\n}\n\nwindow.resizeInput = (e) => {\n  e.preventDefault()\n  const t = e.target\n  const p = t.parentNode\n  const k = e.key\n\n  let step = parseInt(t.value, 10)\n  let stepAtt = parseInt(t.getAttribute('value'), 10)\n  \n  if (step && stepAtt && step !== stepAtt) {\n      t.setAttribute('value', step)\n  } else if (!step) {\n      step = stepAtt || 20\n      t.setAttribute('value', step)\n  }\n  \n  const getCordNum = (str) => parseInt(str.slice(0, -2), 10)\n\n  if (k === 'ArrowLeft') {\n    let left = getCordNum(p.style.left)\n    if (left) {\n      //const newLeft = left - step; if (newLeft <= 0) return;\n      //p.style.left = newLeft + 'px'\n    }\n  }\n  // if (k === 'ArrowRight') {\n  //   let left = getCordNum(p.style.left)\n  //   if (left) p.style.left = left + step + 'px'\n  // }\n  // if (k === 'ArrowUp') {\n  //   let top = getCordNum(p.style.top)\n  //   if (top) {\n  //     const newTop = top - step; if (newTop <= 0) return;\n  //     p.style.top = newTop + 'px'\n  //   }\n  // }\n  // if (k === 'ArrowDown') {\n  //   let top = getCordNum(p.style.top)\n  //   if (top) p.style.top = top + step + 'px'\n  // }\n}\n\n{\n  const div = mk(null, app)\n  div.innerHTML = await kvRepo.get('persistentHtml') || '<div></div>'\n  const observer = new MutationObserver(async (mutList) => {\n    await kvRepo.set('persistentHtml', div.innerHTML)\n  })\n  observer.observe(div, { childList: true, attributes: true, subtree: true, characterData: true })\n}\n\nconst obWidth = 250\nlet ob = mk('object-browser', app)\nob.style.width = obWidth + 'px'\n//ob.style.height = window.innerHeight + 'px'\n\nob = ob.attachShadow({mode: 'open'})\n  const style = mk(0, ob, 'style')\n  style.textContent = `\n    :host { \n      color: #333333; \n      font-family: Roboto, monospace;\n      font-size: 16px\n    }\n    .op-list-btn {\n      width: 24px;\n      height: 24px;\n      cursor: pointer;\n    }\n    .object { cursor: pointer; }\n    .sys-root, .user-root, .cmd-input { margin-left: 1em; }\n    input {\n      font-family: Roboto, monospace;\n      font-size: 15px\n    }\n  `\n\nconst c = (proto, assign) => Object.assign(Object.create(proto), assign)\nconst x = {\n  modules: {},\n  s(name, o) { this.modules[name] = o },\n  g(name) { return this.modules[name] },\n  x(name, args) { return this.g(name)(args) },\n}\n\nconst importDumpFromUrl = async (db, url) => await importDump(db, await (await fetch(url)).json())\nconst importDump = async (db, objects) => {\n  for (const storeName in objects) {\n    const store = objects[storeName]\n    \n    if (Array.isArray(store)) {\n      for (const object of store) {\n        await db.set({ storeName, id: object.id, value: object })\n      }\n    } else {\n      for (const key in store) {\n        await db.set({ storeName, id: key, value: store[key] })\n      }\n    }\n  }\n}\nconst exportDump = async (db, storeNames = [], dumpName) => {\n  const dump = {}\n\n  for (const storeName of storeNames) {\n    if (storeName === 'kv') {\n      const o = {}\n      const keys = await db.getKeys({ storeName })\n      for (const k of keys) {\n        o[k] = await db.get({ storeName, id: k })\n      }\n      dump[storeName] = o\n    } else {\n      dump[storeName] = await db.getAll({ storeName })\n    }\n  }\n  const a = document.createElement('a')\n  a.href = URL.createObjectURL(new Blob([JSON.stringify(dump)], { type: 'application/json' }))\n  a.download = dumpName || 'dump.json'\n  a.click()\n  URL.revokeObjectURL(a.href)\n}\n\nconst CMDs = {\n  repo: 0,\n  cache: 0,\n  async add([ name ]) {\n    const o = { id: await x.x('ulid'), data: { name } }\n    await this.repo.set(o.id, o)\n  },\n  async del([ name ]) {\n    const id = this.cache.nameToId[name]\n    if (id) await this.repo.del(id)\n  },\n  async 'del-by-id'([ id ]) { await repo.del(id) },\n  async get([ name ]) { \n    const id = this.cache.nameToId[name]\n    if (id) console.log(this.cache.byId[id])\n  },\n  async mv([ oldName, newName ]) { \n    const id = this.cache.byId[oldName]\n    const o = this.cache.nameToId[id]\n    if (!o) return\n    o.data.name = newName\n    await this.repo.set(o.id, o)\n  },\n  async 'import-sys-dump'() {\n    // let fInput = mk(null, itemSystemImport, 'input')\n    // fInput.type = 'file'\n    // fInput.style.marginLeft = '10px'\n    // fInput.addEventListener('change', async(e) => {\n    //   importDump(dbSys, JSON.parse(await readFileFromInput(e.target.files[0])))\n    // })\n    //importDump(dbUser, JSON.parse(await readFileFromInput(e.target.files[0])))\n  },\n}\n\nconst terminal = {\n  cmds: 0,\n  input: 0,\n  kvKey: 0,\n  async run() {\n    \n    const lastVal = await kvRepo.get(this.kvKey)\n    if (lastVal) { \n      this.input.value = lastVal\n      //sysCmdInput.focus()\n    }\n\n    this.input.addEventListener('keyup', async (e) => {\n      const t = this.input.value.trim()\n      await kvRepo.set(this.kvKey, t || '')\n\n      if (e.key !== 'Enter') return\n      const [ cmd, ...args ] = t.split(' ')\n      if (this.cmds[cmd]) this.cmds[cmd](args)\n    })\n  },\n}\n\nconst sysCache = {\n  byId: {},\n  nameToId: {},\n  names: [],\n  unnamed: []\n}\n\nconst sysCMDs = c(CMDs, { \n  repo: sysObjectsRepo,\n  cache: sysCache,\n  async 'export-dump'() { exportDump(dbSys, ['objects'], 'dump.json') },\n})\n\n\nconst userCache = {\n  byId: {},\n  nameToId: {},\n  names: [],\n  unnamed: []\n}\n\nconst userCMDs = c(CMDs, { \n  repo: userObjectsRepo,\n  cache: userCache,\n  async 'export-dump'() { exportDump(dbUser, ['objects', 'kv'], 'user.json') },\n})\n\nconst sysCmdInput = mk('.cmd-input', ob, 'input')\nsysCmdInput.setAttribute('placeholder', 'Insert cmd...')\n\nconst sysTerminal = c(terminal, {\n  cmds: sysCMDs,\n  input: sysCmdInput,\n  kvKey: 'sys-cmd-input',\n})\nawait sysTerminal.run()\n\nob.sysRoot = mk('.sys-root', ob); mk(null, ob, 'br')\n\nconst userCmdInput = mk('.cmd-input', ob, 'input')\nuserCmdInput.setAttribute('placeholder', 'Insert cmd...')\n\nconst userTerminal = c(terminal, {\n  cmds: userCMDs,\n  input: userCmdInput,\n  kvKey: 'user-cmd-input',\n})\nawait userTerminal.run()\n\nob.userRoot = mk('.user-root', ob)\n\n\nconst readFileFromInput = async (fileInput) => {\n  const { promise, resolve, reject } = Promise.withResolvers()  \n  const r = new FileReader()\n  r.readAsText(fileInput)\n  r.onload = async () => resolve(r.result)\n  r.onerror = reject\n  return promise\n}\n\nconst opListManager = {\n  opList: null,\n  createOpList() {\n    if (this.opList) {\n      this.removeOpList()\n      return\n    }\n    this.opList = mk('.op-list', app)\n    const style = mk(null, this.opList, 'style')\n    style.innerHTML = `\n      .op-list {\n        min-width: 10em;\n        position: absolute;\n        background: #f3f3f3;\n        color: #616161;\n        font-family: Roboto, sans-serif;\n        box-shadow: rgba(2, 0, 0, 0.35) 0px 5px 15px;\n        cursor: pointer;\n        z-index: 1000;\n      }\n      .op-list-item {\n        padding: 5px;\n      }\n      .op-list-item:hover {\n        background:rgb(221, 221, 221);\n      }          \n    `\n    return this.opList\n  },\n  removeOpList() {\n    this.opList.remove()\n    this.opList = null\n  }\n}\n\nconst tabManager = {\n  activeTab: null,\n  init(target, mk, width) {\n    const tabsContainer = mk('tabs-container', target)\n    tabsContainer.style.width = width\n    const style = mk(null, tabsContainer, 'style')\n    style.innerHTML = `\n      #tabs-bar { display: flex; }\n      .tab {\n        display: flex;\n        padding: 5px;\n        align-items: center;\n        cursor: pointer;\n      }\n      .tab.active {\n        background: #e2e2e2;\n      }\n      .tab-name {\n        font-family: Roboto, sans-serif;\n        margin-right: 3px;\n        color: #333333;\n      }\n      .tab-view.hidden {\n        display: none;\n      }\n      .object-code {\n        font-family: 'JetBrains Mono', monospace;\n      }\n      .close-tab-btn {\n        width: 18px;\n        height: 18px;\n        stroke: currentColor;\n      }\n    `\n\n    this.tabsBarHeight = 35\n    this.tabsBar = mk('tabs-bar', tabsContainer)\n\n    this.tabsView = mk('tabs-view', tabsContainer)\n    this.tabsView.style.height = window.innerHeight - this.tabsBarHeight + 'px' \n    this.tabsView.style.overflow = 'scroll'\n  },\n  openTab(repo, object) {\n\n    const tab = mk(null, this.tabsBar)\n    tab.className = 'tab active'\n    tab.setAttribute('object-id', object.id)\n    tab.addEventListener('click', () => {\n      this.activateTab(tab)\n      this.saveActiveTab(object.id)\n    })\n\n    tab.name = mk(null, tab)\n    tab.name.className = 'tab-name'\n    tab.name.textContent = object.data.name\n\n    tab.closeBtn = mk('.close-tab-btn', tab)\n    tab.closeBtn.addEventListener('click', (e) => {\n      e.stopPropagation()\n\n      let nextTab\n\n      if (tab === this.activeTab) {\n        const tabs = this.tabsBar.children\n        const tabIndex = Array.from(tabs).indexOf(tab)\n        \n        nextTab = tabIndex > 0 \n          ? tabs[tabIndex - 1]\n          : tabs[tabIndex + 1];\n      }\n\n      this.closeTab(tab)\n      objectManager.closeObject(object, 'tabManager')\n\n      if (nextTab) {\n        this.activateTab(nextTab)\n        this.saveActiveTab(nextTab.getAttribute('object-id'))\n      } else {\n        this.clearActiveTab()\n      }\n    })\n    tab.closeBtn.innerHTML += '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M6 18 18 6M6 6l12 12\"></path></svg>'\n    tab.view = mk('.tab-view', this.tabsView)\n\n    const pre = mk('object-code', tab.view, 'div')\n    pre.style.height = window.innerHeight - this.tabsBarHeight + 'px' \n    const editor = monaco.editor.create(pre, {\n      value: object.data.code, \n      language: 'javascript',\n      theme: 'vs-dark', \n      automaticLayout: true, \n      fontSize: 15\n    })\n\n    const openedObjects = objectManager.getOpenedObjects()\n    const pos = openedObjects[object.id]\n    if (pos && typeof pos === 'object') editor.revealPositionInCenter(pos)\n\n    editor.onDidChangeModelContent((e) => {\n      if (!object.id) return\n      \n      const pos = editor.getPosition()\n      objectManager.openObject(object, pos)\n      object.data.code = editor.getValue()\n\n      repo.set(object.id, object)\n    })\n\n    this.activateTab(tab)\n  },\n  closeTab(tab) {\n    tab.remove()\n    tab.view.remove()\n  },\n  activateTab(tab) {\n    if (this.activeTab) {\n      this.activeTab.classList.remove('active')\n      this.activeTab.view.classList.add('hidden')\n    }\n    tab.classList.add('active')\n    tab.view.classList.remove('hidden')\n    this.activeTab = tab\n  },\n  saveActiveTab(id) {\n    kvRepo.set('activeTabId', id)\n  },\n  clearActiveTab() {\n    kvRepo.del('activeTabId')\n  },\n  async restoreLastActiveTab() {\n    const value = await kvRepo.get('activeTabId')\n    if (!value) return\n\n    const tab = this.tabsBar.querySelector(`[object-id=\"${value}\"]`)\n    if (!tab) return\n    this.activateTab(tab)\n  }\n}\n\nconst tabManagerWidth = `calc(100% - ${obWidth}px)`\ntabManager.init(app, mk, tabManagerWidth)\n\nconst objectManager = {\n  openedObjectsIds: {},\n\n  async init() {\n    const v = await kvRepo.get('openedObjectsIds')\n    if (v) this.openedObjectsIds = v\n  },\n  getOpenedObjects() {\n    return this.openedObjectsIds\n  },\n  isObjectOpened(objectId) {\n    return Boolean(this.openedObjectsIds[objectId])\n  },\n  openObject(object, pos) {\n    this.openedObjectsIds[object.id] = pos ? pos : 1\n    this.saveOpenedObjects()\n  },\n  closeObject(object) {\n    delete this.openedObjectsIds[object.id]\n    this.saveOpenedObjects()\n  },\n  saveOpenedObjects() {\n    kvRepo.set('openedObjectsIds', this.openedObjectsIds)\n  },\n}\nawait objectManager.init()\n\nconst renderObject = (object, target, repo) => {\n  const d = mk(object.id, target)\n  d.className = 'object'\n\n  d.name = mk(null, d)\n  d.name.innerText = object.data.name\n  d.name.addEventListener('click', async (e) => {\n    if (objectManager.isObjectOpened(object.id)) return\n    \n    tabManager.openTab(repo, object)\n    tabManager.saveActiveTab(object.id)\n    objectManager.openObject(object)\n  })\n\n  const children = mk(null, d)\n  children.className = 'children'\n\n  return { objectDom: d, children }\n}\n\nconst mkObservableObject = async (objectsRepository, object) => {\n  const isObj = (o) => typeof o === 'object' && o !== null\n  const onUpdateCallback = () => {} // objectStore.saveById(object.id)\n\n  const mkObservable = (obj) => {\n    for (const k in obj) {\n      if (isObj(obj[k])) {\n        console.log(k)\n        obj[k] = mkObservable(obj[k])\n      }\n    }\n\n    return new Proxy(obj, {\n      set: (target, prop, value) => {\n        if (isObj(value)) value = mkObservable(value)\n        if (Array.isArray(target) && prop === 'length') return true\n\n        target[prop] = value\n        if (prop === '_') return true\n\n        onUpdateCallback()\n        return true\n      },\n      deleteProperty: (target, prop) => {\n        delete target[prop]\n        onUpdateCallback()\n        return true\n      },\n    })\n  }\n\n  return mkObservable(object)\n}\n\nconst process = async (repo, cache, targetDiv) => {\n  const objects = await repo.getAll()\n \n  for (let i = 0; i < objects.length; i++) {\n    const o = objects[i]\n    const name = o.data.name\n\n    cache.byId[o.id] = o\n    cache.nameToId[name] = o.id\n    cache.names.push(name)\n\n    if (o.id !== 'sys-main' && o.data.code) {\n      try {\n        const fn = await createFnFromCode(o.data.code)\n        x.s(name, fn)\n      } catch (e) {\n        console.error(e)\n      }\n    }\n  }\n  \n  const sortedNames = cache.names.sort()\n  for (let i = 0; i < sortedNames.length; i++) {\n    const name = sortedNames[i]\n\n    const id = cache.nameToId[name]\n    const o = cache.byId[id]\n\n    if (o.id !== 'sys-main' && o.data.code) {\n      try {\n        const fn = x.g(name)\n        await fn({ object: o, x })\n      } catch (e) {\n        console.error(e)\n      }\n    }\n    if (objectManager.isObjectOpened(o.id)) {\n      tabManager.openTab(repo, o)\n    }\n    renderObject(o, targetDiv, repo)\n  }\n}\n\nawait process(sysObjectsRepo, sysCache, ob.sysRoot)\nawait process(userObjectsRepo, userCache, ob.userRoot)\n\nawait tabManager.restoreLastActiveTab()","name":"sys-main"}}]}