{"objects":[{"id":"01JYBFKQ8RA0TN6S0Z58MV3CRS","data":{"name":"ulid"},"sliceEditor":"1","cutEditor":"1"},{"id":"01JYBP723DJ3BFT3DDC29X99BR","data":{"name":"psbus"},"cutEditor":"1"},{"id":"01JZ0VDJR11BDSQR2XANYHW69E","data":{"name":"tes"},"type":"noun","code":"//bro bro bro////\n\nconst psbus = () => {\n\n  const createDataProxy = (data, x) => new Proxy(() => {}, {\n    get(target, prop) {\n      if (prop === 'p') return (...args) => x.p(...args)\n      if (prop === 's') return (...args) => { x.s(...args); return x; }\n      if (prop === 'toJSON') return () => data\n      return data[prop]\n    },\n    set(target, prop, value) {\n      data[prop] = value\n      return true\n    },\n  })\n\n  const x = {\n    events: {},\n    func: {},\n\n    async p(event, data = {}) {\n      const dataObject = typeof data === 'function' ? data : createDataProxy(data, x)\n      const func = this.func[event]\n\n      if (!func) {\n        const events = this.events\n        if (!events[event]) events[event] = []\n\n        const { promise, resolve } = Promise.withResolvers()\n        events[event].push({ data, resolve })\n        console.log(`deferred event [${event}]`)\n        return promise\n      }\n\n      if (typeof func !== 'function') console.log(event, func);\n      return func(dataObject);\n    },\n\n    async s(event, func) {\n      this.func[event] = func;\n      const events = this.events[event];\n      if (!events) return this;\n\n      console.log(`executed deferred event > [${event}]`);\n      for (const { data, resolve } of events) {\n        const response = await this.p(event, data);\n        resolve(response);\n      }\n\n      delete this.events[event];\n      return this;\n    },\n  };\n\n  return x\n}\n\nconst x = {\n  objects: {},\n  s(name, o) { this.objects[name] = o },\n  g(name) { return this.objects[name] },\n  x(name, args) { \n    if (!this.g(name)) console.log(name)\n    return this.g(name)(args) \n  },\n}\n\nconst mkObservableObject = async (objectsRepository, object) => {\n  const isObj = (o) => typeof o === 'object' && o !== null\n  const onUpdateCallback = () => {} // objectStore.saveById(object.id)\n\n  const mkObservable = (obj) => {\n    for (const k in obj) {\n      if (isObj(obj[k])) {\n        console.log(k)\n        obj[k] = mkObservable(obj[k])\n      }\n    }\n\n    return new Proxy(obj, {\n      set: (target, prop, value) => {\n        if (isObj(value)) value = mkObservable(value)\n        if (Array.isArray(target) && prop === 'length') return true\n\n        target[prop] = value\n        if (prop === '_') return true\n\n        onUpdateCallback()\n        return true\n      },\n      deleteProperty: (target, prop) => {\n        delete target[prop]\n        onUpdateCallback()\n        return true\n      },\n    })\n  }\n\n  return mkObservable(object)\n}\n\n// {\n//   const div = mk(null, app)\n//   div.innerHTML = await kvRepo.get('persistentHtml') || '<div></div>'\n//   const observer = new MutationObserver(async (mutList) => {\n//     await kvRepo.set('persistentHtml', div.innerHTML)\n//   })\n//   observer.observe(div, { childList: true, attributes: true, subtree: true, characterData: true })\n// }\n\n////"},{"id":"sys-main","data":{"name":"sys-main"},"code":"const ulid = (() => {\n  const ENCODING = '0123456789ABCDEFGHJKMNPQRSTVWXYZ';\n  const ENCODING_LEN = ENCODING.length;\n  const TIME_LEN = 10;\n  const RANDOM_LEN = 16;\n  const TIME_MAX = Math.pow(2, 48) - 1;\n\n  let lastTime = 0;\n  let lastRandom = '';\n\n  function getPRNG(allowInsecure) {\n    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n      return () => {\n        const buf = new Uint8Array(1);\n        crypto.getRandomValues(buf);\n        return buf[0] / 0xff;\n      };\n    }\n    if (allowInsecure) return () => Math.random();\n    throw new Error('secure crypto unavailable');\n  }\n\n  function randChar(rng) {\n    let r = Math.floor(rng() * ENCODING_LEN);\n    if (r === ENCODING_LEN) r = ENCODING_LEN - 1;\n    return ENCODING[r];\n  }\n\n  function encodeTime(ms) {\n    if (!Number.isInteger(ms) || ms < 0 || ms > TIME_MAX) {\n      throw new Error('invalid time');\n    }\n    let str = '';\n    for (let i = 0; i < TIME_LEN; i++) {\n      str = ENCODING[ms % ENCODING_LEN] + str;\n      ms = Math.floor(ms / ENCODING_LEN);\n    }\n    return str;\n  }\n\n  function encodeRandom(rng) {\n    let str = '';\n    for (let i = 0; i < RANDOM_LEN; i++) {\n      str = randChar(rng) + str;\n    }\n    return str;\n  }\n\n  function increment(str) {\n    const arr = str.split('');\n    for (let i = arr.length - 1; i >= 0; i--) {\n      const idx = ENCODING.indexOf(arr[i]);\n      if (idx < 0) throw new Error('invalid random component');\n      if (idx < ENCODING_LEN - 1) {\n        arr[i] = ENCODING[idx + 1];\n        return arr.join('');\n      }\n      arr[i] = ENCODING[0];\n    }\n    throw new Error('cannot increment');\n  }\n\n  return function ({ monotonic = false, allowInsecure = false, prng, time } = {}) {\n    const ms = Number.isInteger(time) ? time : Date.now();\n    const rng = prng || getPRNG(allowInsecure);\n\n    if (monotonic) {\n      if (ms <= lastTime) {\n        lastRandom = increment(lastRandom);\n      } else {\n        lastTime = ms;\n        lastRandom = encodeRandom(rng);\n      }\n      return encodeTime(lastTime) + lastRandom;\n    }\n\n    return encodeTime(ms) + encodeRandom(rng);\n  }\n})()\n\n// input.addEventListener('change', event => {\n//     const file = event.target.files[0]\n//     if (!file) return\n//     const r = new FileReader()\n//     r.readAsArrayBuffer(file)\n//     r.onload = async () => {\n//         const arrBuf = r.result\n//         const data = { bin: r.result, binMeta: { name: file.name } }\n//     }\n// })\n\nclass IndexedDb {  \n  async open(dbName = 'default', storages = ['default']) {\n    return new Promise((resolve, reject) => {\n      const openRequest = indexedDB.open(dbName)\n      \n      openRequest.onerror = () => {\n        reject(openRequest.error)\n      }\n      openRequest.onsuccess = () => {\n        this.db = openRequest.result\n        resolve(this.db)\n      }\n      openRequest.onupgradeneeded = () => {\n        const db = openRequest.result\n        \n        for (const storageName of storages) {\n          if (!db.objectStoreNames.contains(storageName)) {\n            db.createObjectStore(storageName)\n          }\n        }\n      }\n    })\n  }\n  async set(x) {\n    const { storeName = 'default', id, value } = x\n\n    return new Promise((resolve, reject) => {\n      const rq = this.db.transaction(storeName, 'readwrite').objectStore(storeName).put(value, id)\n      rq.onsuccess = () => resolve(rq.result)\n      rq.onerror = () => reject(rq.error)\n    })\n  }\n  async get(x) {\n    const { storeName = 'default', id } = x\n\n    return new Promise((resolve, reject) => {\n      const rq = this.db.transaction(storeName, 'readonly').objectStore(storeName).get(id)\n      rq.onsuccess = () => resolve(rq.result)\n      rq.onerror = () => reject(rq.error)\n    })\n  }\n  async getAll(x) {\n    const { storeName = 'default' } = x\n    return new Promise((resolve, reject) => {\n      const rq = this.db.transaction(storeName, 'readonly').objectStore(storeName).getAll()\n      rq.onsuccess = () => resolve(rq.result)\n      rq.onerror = () => reject(rq.error)\n    })\n  }\n  async getKeys(x) {\n    const { storeName = 'default' } = x\n    return new Promise((resolve, reject) => {\n      const rq = this.db.transaction(storeName, 'readonly').objectStore(storeName).getAllKeys()\n      rq.onsuccess = () => resolve(rq.result)\n      rq.onerror = () => reject(rq.error)\n    })\n  }\n  async del(x) {\n    const { storeName = 'default', id } = x\n\n    return new Promise((resolve, reject) => {\n      const rq = this.db.transaction(storeName, 'readwrite').objectStore(storeName).delete(id)\n      rq.onsuccess = () => resolve(rq.result)\n      rq.onerror = () => reject(rq.error)\n    })\n  }\n}\n\nclass BaseRepo {\n  db = null\n  table = null\n  mainObjectId = null\n\n  init(db, mainObjectId) { \n    this.db = db\n    this.mainObjectId = mainObjectId\n  }\n  async get(id) {\n    return await this.db.get({ storeName: this.table, id })\n  }\n  async getAll() {\n    return await this.db.getAll({ storeName: this.table })\n  }\n  async set(id, object) {\n      await this.db.set({ storeName: this.table, id, value: object }) \n  }\n  async del(id) {\n    await this.db.del({ storeName: this.table, id })\n  }\n}\nclass ObjectsRepository extends BaseRepo { \n  table = 'objects' \n}\nclass KvRepo extends BaseRepo {\n  table = 'kv'\n  async get(key) {\n    return await this.db.get({ storeName: this.table, id: key })\n  }\n  async set(key, value) {\n    await this.db.set({ storeName: this.table, id: key, value })\n  }\n  async del(key) {\n    await this.db.del({ storeName: this.table, id: key })\n  }\n}\n\nconst dbSys = new IndexedDb\nawait dbSys.open('sys', ['objects'])\nconst dbUser = new IndexedDb\nawait dbUser.open('user', ['objects', 'kv'])\n\nconst sysRepo = new ObjectsRepository\nsysRepo.init(dbSys, 'sys-main')\n\nconst userRepo = new ObjectsRepository\nuserRepo.init(dbUser, '01JXMZQQNVWQT62KCDZ403HCTA') //refactor just search by name \"main\"\n\nconst kvRepo = new KvRepo\nkvRepo.init(dbUser)\n\nconst mk = (id, target, tag = 'div') => {\n  const el = document.createElement(tag)\n  if (id) {\n    if (id[0] === '.') {\n      el.className = id.slice(1)\n    } else {\n      el.id = id\n    }\n  }\n  if (target) target.append(el)\n  \n  return el\n}\n//x.s('mk', mk)\n\nconst c = (proto, assign = {}) => Object.assign(Object.create(proto), assign)\n\nconst createFnFromCode = async (codeStr) => {\n  const code = `export default async ($) => { \n    ${codeStr} \n  }`\n  const blob = new Blob([code], { type: 'application/javascript' })\n  return (await import(URL.createObjectURL(blob))).default\n}\n\nconst importDump = async (db, objects) => {\n  for (const storeName in objects) {\n    const store = objects[storeName]\n    \n    if (Array.isArray(store)) {\n      for (const object of store) {\n        await db.set({ storeName, id: object.id, value: object })\n      }\n    } else {\n      for (const key in store) {\n        await db.set({ storeName, id: key, value: store[key] })\n      }\n    }\n  }\n}\n\nconst exportDump = async (db, storeNames = [], dumpName) => {\n  const dump = {}\n\n  for (const storeName of storeNames) {\n    if (storeName === 'kv') {\n      const o = {}\n      const keys = await db.getKeys({ storeName })\n      for (const k of keys) {\n        o[k] = await db.get({ storeName, id: k })\n      }\n      dump[storeName] = o\n    } else {\n      dump[storeName] = await db.getAll({ storeName })\n    }\n  }\n  const a = document.createElement('a')\n  a.href = URL.createObjectURL(new Blob([JSON.stringify(dump)], { type: 'application/json' }))\n  a.download = dumpName || 'dump.json'\n  a.click()\n  URL.revokeObjectURL(a.href)\n}\n\ndocument.body.style.margin = 0\nconst app = mk('app', document.body)\napp.style.display = 'flex'\n\nmk('app-vue', document.body)\n\n//LOAD FONTS\n{\n  const fontUrl = 'https://fonts.googleapis.com/css2?family';\n  [\n    `${fontUrl}=Roboto:wght@400;700&display=swap`,\n    `${fontUrl}=JetBrains+Mono:wght@400;700&display=swap`\n  ].forEach(url => {\n    const link = mk(null, document.head, 'link')\n    link.rel = 'stylesheet'\n    link.href = url\n  })\n}\n\n//LOAD MONACO EDITOR\n{\n  const { promise: editorIsReady, resolve: editorIsReadyResolve } = Promise.withResolvers()\n  const requireScript = document.createElement('script');\n  requireScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js'\n  requireScript.onload = () => {\n      require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs' } })\n      require(['vs/editor/editor.main'], editorIsReadyResolve)\n  }\n  document.head.append(requireScript)\n  await editorIsReady\n}\n\n//LOAD VUE\n{\n  const Vue = await import('https://unpkg.com/vue@3/dist/vue.esm-browser.prod.js')\n  const { createApp, defineComponent, ref, toRaw, onMounted, watch } = Vue\n\n  const ObjectManager = defineComponent({\n    name: 'ObjectManager',\n    props: ['repoName', 'objects', 'width', 'openObjectCallback'],\n    setup: (props) => {\n      const input = ref('')\n\n      // const lastVal = await kvRepo.get(this.kvKey)\n      // if (lastVal) { \n      //   inputVal.value = lastVal\n      //\n\n      const onKeyUp = (e) => {\n        if (e.code !== 'Enter') return\n        //await kvRepo.set(key, t || '')\n\n        const [ cmd, ...args ] = input.value.split(' ')\n        const CMDs = props.repoName === 'sys' ? sysCMDs : userCMDs\n        if (CMDs[cmd]) CMDs[cmd](args)\n      }\n      return { input, onKeyUp }\n    },\n    template: `\n      <div class=\"object-manager\" :style=\"{ width: width + 'px' }\">\n        <input placeholder=\"input cmd\" @keyup=\"onKeyUp($event)\" v-model=\"input\">\n        <div \n          v-for=\"(o, objectId) in objects\" \n          :key=\"objectId\"\n          class=\"object\"\n          @click=\"openObjectCallback(repoName, objectId)\"\n        >\n          {{o.data.name}}\n        </div>\n      </div>\n    `\n  })\n\n  const MonacoEditor = defineComponent({\n    name: 'MonacoEditor',\n    props: ['repoName', 'objectId', 'code', 'position', 'updateCallback'],\n    setup(props) {\n      const codeContainer = ref(null)\n\n      onMounted(() => {\n        const editor = monaco.editor.create(codeContainer.value, {\n            value: props.code,\n            language: 'javascript',\n            theme: 'vs-dark',\n            automaticLayout: true,\n            fontSize: 15\n        })\n        editor.onDidChangeModelContent((e) => {  \n          props.updateCallback({\n            repoName: props.repoName,\n            objectId: props.objectId,\n            code: editor.getValue(),\n            position: editor.getPosition()\n          })\n        })\n        if (props.position) {\n          editor.revealPositionInCenter(props.position)\n        }\n      })\n\n      return { codeContainer }\n    },\n    template: `\n    <div ref=\"codeContainer\" style=\"margin: 0; height: ${window.innerHeight}px\"></div>`\n  })\n\n  const TabManager = defineComponent({\n    name: 'TabManager',\n    components: { MonacoEditor },\n    props: [\n      'width',\n      'sys', 'user', 'tabs', 'activeTabId', \n      'updateObjectCallback',\n      'activateTabCallback', 'closeTabCallback'\n    ],\n    setup(props) {\n      \n    },\n    template: `\n      <div class=\"tabs-container\" :style=\"{ width: width + 'px' }\">\n        <div class=\"tabs-bar\">\n          <div class=\"tab\"\n              @click=\"activateTabCallback(tab.object.id)\" \n              :class=\"activeTabId === tab.object.id ? 'active': ''\" \n              v-for=\"tab in tabs\" :key=\"tab.object.id\">\n\n              <div class=\"tab-name\">{{tab.object.data.name}}</div>\n              <div class=\"close-tab-btn\" @click.stop=\"closeTabCallback(tab.object.id)\">\n                <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M6 18 18 6M6 6l12 12\"></path></svg>\n              </div>\n          </div>\n        </div>\n        \n        <div v-for=\"tab in tabs\" :key=\"tab.object.id\">\n          <MonacoEditor\n            v-if=\"activeTabId === tab.object.id\"\n            :repoName=\"tab.repoName\"\n            :objectId=\"tab.object.id\"\n            :code=\"tab.object.code\"\n            :position=\"tab.position\"\n            :updateCallback=updateObjectCallback \n          />\n        </div>\n      </div>\n    `\n  })\n\n  const mainComponent = defineComponent({\n    name: 'Main',\n    components: { ObjectManager, TabManager },\n    setup() {\n      const sys = ref({})\n      const user = ref({})\n      const openedObjects = ref([])\n\n      const tabs = ref([])\n      const activeTabId = ref('')\n\n      const openObjectCallback = (repoName, id) => {\n        openedObjects.value.push({ repoName, id })\n        activateTabCallback(id)\n      }\n      const updateObjectCallback = (update) => {\n\n        const repo = update.repoName === 'sys' ? sysRepo : userRepo\n        const objectsRef = update.repoName === 'sys' ? sys : user\n        const object = objectsRef.value[update.objectId]\n\n        if (!object) return\n\n        const value = openedObjects.value\n        for (let i = 0; i < value.length; i++) {\n          const openedObject = value[i]\n          if (openedObject.repoName === update.repoName &&\n              openedObject.id === object.id\n          ) {\n            openedObject.position = update.position\n            break\n          }\n        }\n\n        const o = toRaw(object)\n        o.code = update.code\n        repo.set(o.id, o)\n        \n        //console.log('updateObjectCallback', repoName, update)\n        //also update pos on openedObjects\n      }\n      const closeTabCallback = (tabId) => {\n        \n        let nextTab\n\n        if (tabId === activeTabId.value) {\n          const tabIndex = tabs.value.findIndex(t => t.object.id === tabId)\n          nextTab = tabIndex > 0 \n            ? tabs.value[tabIndex - 1]\n            : tabs.value[tabIndex + 1]\n        }\n        tabs.value = tabs.value.filter((tab) => tab.object.id !== tabId)\n        openedObjects.value = openedObjects.value.filter((object => {\n          return object.id !== tabId\n        }))\n        if (nextTab) {\n          activateTabCallback(nextTab.object.id)        \n        }\n      }\n        \n      const rebuildTabs = async () => {\n        tabs.value = []\n        for (const openedObject of openedObjects.value) {\n\n          const objectsRef = openedObject.repoName === 'sys' ? sys.value : user.value\n          tabs.value.push({\n            object: objectsRef[openedObject.id],\n            ...openedObject\n          })\n        }\n      }\n      const activateTabCallback = (tabId) => {\n        if (activeTabId.value === tabId) return\n        activeTabId.value = tabId\n      }\n\n      const sideBarWidth = 270\n      const tabManagerWidth = window.innerWidth - sideBarWidth\n      \n      onMounted(async () => {\n          for (const o of (await sysRepo.getAll())) sys.value[o.id] = o\n          for (const o of (await userRepo.getAll())) user.value[o.id] = o\n          openedObjects.value = await kvRepo.get('openedObjects') ?? []\n          activeTabId.value = await kvRepo.get('activeTabId') ?? null\n\n          watch(\n            openedObjects,\n            (newOpenedObjects) => {\n              const arr = newOpenedObjects.map(proxyItem => toRaw(proxyItem))\n              kvRepo.set('openedObjects', arr)\n              rebuildTabs()\n            },\n            { deep: true }\n          )\n          watch(\n            activeTabId,\n            (newActiveTabId) => kvRepo.set('activeTabId', newActiveTabId),\n          )\n          \n          rebuildTabs()\n      })\n\n      const style = document.createElement('style')\n      style.textContent = `\n        .app-container { display: flex; }\n        .object-manager { \n          color: #333333; \n          font-family: Roboto, monospace;\n          font-size: 16px;\n          margin-left: 10px;\n        }\n        .op-list-btn {\n          width: 24px;\n          height: 24px;\n          cursor: pointer;\n        }\n        .object { cursor: pointer; }\n        .sys-root, .user-root,\n        .cmd-input, .file-input { margin-left: 1em; }\n        input {\n          font-family: Roboto, monospace;\n          font-size: 15px\n        }\n        .tabs-bar { display: flex; }\n        .tab {\n          display: flex;\n          gap: 4px;\n          padding: 5px;\n          align-items: center;\n          cursor: pointer;\n        }\n        .tab.active {\n          background: #e2e2e2;\n        }\n        .tab-name {\n          font-family: Roboto, sans-serif;\n          color: #333333;\n        }\n        .tab-view.hidden {\n          display: none;\n        }\n        .close-tab-btn {\n          width: 18px;\n          height: 18px;\n          stroke: currentColor;\n        }\n      `\n      document.head.appendChild(style)\n\n      return { \n        sys, user,\n        openObjectCallback, updateObjectCallback, activateTabCallback, closeTabCallback,\n        tabs, activeTabId,\n        sideBarWidth, tabManagerWidth\n      }\n    },\n    template: `\n      <div class=\"app-container\">\n        <div class=\"left-sidebar\" :style=\"{ width: sideBarWidth + 'px' }\">\n          <ObjectManager \n            repoName=\"sys\"\n            :objects=\"sys\"\n            :openObjectCallback=\"openObjectCallback\" \n          />\n          <br>\n          <ObjectManager\n            repoName=\"user\"\n            :objects=\"user\"\n            :openObjectCallback=\"openObjectCallback\" \n          />\n        </div>\n        <TabManager\n          :width=\"tabManagerWidth\" \n          :sys=\"sys\"\n          :user=\"user\"\n          :tabs=\"tabs\"\n          :activeTabId=\"activeTabId\"\n          :activateTabCallback=\"activateTabCallback\"\n          :updateObjectCallback=\"updateObjectCallback\"\n          :closeTabCallback=\"closeTabCallback\"\n        />\n      </div> \n    `\n  })\n\n  const app = createApp(mainComponent)\n  app.mount('#app-vue')\n}\n\nconst obWidth = 250\nlet ob = mk('.object-browser', app)\nob.style.display = 'none'\n\nob.style.width = obWidth + 'px'\n\nob = ob.attachShadow({mode: 'open'})\nconst style = mk(0, ob, 'style')\nstyle.textContent = `\n  :host { \n    color: #333333; \n    font-family: Roboto, monospace;\n    font-size: 16px\n  }\n  .op-list-btn {\n    width: 24px;\n    height: 24px;\n    cursor: pointer;\n  }\n  .object { cursor: pointer; }\n  .sys-root, .user-root,\n  .cmd-input, .file-input { margin-left: 1em; }\n  input {\n    font-family: Roboto, monospace;\n    font-size: 15px\n  }\n`\n\nconst CMDs = {\n  repo: 0,\n  cache: 0,\n  async add([ name ]) {\n    const o = { id: await x.x('ulid'), data: { name: name.trim() } }\n    o.type = 'noun'\n    await this.repo.set(o.id, o)\n  },\n  async del([ name ]) {\n    const id = this.cache.nameToId[name]\n    if (id) await this.repo.del(id)\n  },\n  async 'del-by-id'([ id ]) { await repo.del(id) },\n  async get([ name ]) { \n    const id = this.cache.nameToId[name]\n    if (id) console.log(this.cache.byId[id])\n  },\n  async mv([ oldName, newName ]) {     \n    const id = this.cache.nameToId[oldName]\n    const o = this.cache.byId[id]\n    if (!o) return\n    o.data.name = newName\n    await this.repo.set(o.id, o)\n  },\n  async set([ name, k, v ]) {\n    const id = this.cache.nameToId[name]\n    if (!id) return\n    const o = this.cache.byId[id]\n    o[k] = v\n    if (!v) delete o[k]\n    \n    await this.repo.set(o.id, o)\n  },\n  async 'set-json'([ name, json ]) {\n    const id = this.cache.nameToId[name]\n    if (!id) return\n    //const o = this.cache.byId[id]\n    //Object.assign(o, )\n  }\n}\n\nconst terminal = {\n  cmds: 0,\n  kvKey: 0,\n  async run() {\n    this.input.addEventListener('keyup', async (e) => {\n      //const t = this.input.value.trim()\n    })\n  },\n}\n\nconst sysCache = {\n  byId: {},\n  nameToId: {},\n  names: [],\n  unnamed: []\n}\nconst sysCMDs = c(CMDs, { \n  repo: sysRepo,\n  cache: sysCache,\n  async 'export-dump'() { exportDump(dbSys, ['objects'], 'dump.json') },\n})\n\nconst userCache = {\n  byId: {},\n  nameToId: {},\n  names: [],\n  unnamed: []\n}\n//x.s('userCache', userCache)\n\n\nconst userCMDs = c(CMDs, { \n  repo: userRepo,\n  cache: userCache,\n  async 'import-dump'() {\n    const fInput = mk('.file-input', null, 'input')\n    fInput.type = 'file'\n    fInput.addEventListener('change', async (e) => {\n      const dump = JSON.parse(await readFileFromInput(e.target.files[0]))\n      importDump(dbUser, dump)\n    })\n    userCmdInput.before(fInput)\n  },\n  async 'export-dump'() { exportDump(dbUser, ['objects', 'kv'], 'user.json') },\n})\n\nconst sysCmdInput = mk('.cmd-input', ob, 'input')\nsysCmdInput.setAttribute('placeholder', 'Insert cmd...')\n\nconst sysTerminal = c(terminal, {\n  cmds: sysCMDs,\n  input: sysCmdInput,\n  kvKey: 'sys-cmd-input',\n})\nawait sysTerminal.run()\n\nob.sysRoot = mk('.sys-root', ob); mk(null, ob, 'br')\n\nconst userCmdInput = mk('.cmd-input', ob, 'input')\nuserCmdInput.setAttribute('placeholder', 'Insert cmd...')\n\nconst userTerminal = c(terminal, {\n  cmds: userCMDs,\n  input: userCmdInput,\n  kvKey: 'user-cmd-input',\n})\nawait userTerminal.run()\n\nob.userRoot = mk('.user-root', ob)\n\nconst readFileFromInput = async (fileInput) => {\n  const { promise, resolve, reject } = Promise.withResolvers()  \n  const r = new FileReader()\n  r.readAsText(fileInput)\n  r.onload = async () => resolve(r.result)\n  r.onerror = reject\n  return promise\n}\n\nconst tabManager = {\n  activeTab: null,\n  init(target, mk, width) {\n\n    const tabsContainer = mk('.tabs-container', target)\n    tabsContainer.style.width = width\n    const style = mk(null, tabsContainer, 'style')\n    style.innerHTML = `\n      .tabs-bar { display: flex; }\n      .tab {\n        display: flex;\n        padding: 5px;\n        align-items: center;\n        cursor: pointer;\n      }\n      .tab.active {\n        background: #e2e2e2;\n      }\n      .tab-name {\n        font-family: Roboto, sans-serif;\n        margin-right: 3px;\n        color: #333333;\n      }\n      .tab-view.hidden {\n        display: none;\n      }\n      .object-code {\n        margin: 0;\n        outline: none;\n        font-size: 15px;\n        font-family: 'JetBrains Mono', monospace;\n        font-variant-ligatures: none;\n      }\n      .close-tab-btn {\n        width: 18px;\n        height: 18px;\n        stroke: currentColor;\n      }\n    `\n\n    this.tabsBarHeight = 35\n    this.tabsBar = mk('.tabs-bar', tabsContainer)\n\n    this.tabsView = mk('.tabs-view', tabsContainer)\n    this.tabsView.style.height = window.innerHeight - this.tabsBarHeight + 'px' \n  },\n  async openTab(repo, object) {\n    const tab = mk(null, this.tabsBar)\n    tab.className = 'tab active'\n    tab.setAttribute('object-id', object.id)\n    tab.addEventListener('click', () => {\n      this.activateTab(tab)\n      this.saveActiveTab(object.id)\n    })\n\n    tab.name = mk(null, tab)\n    tab.name.className = 'tab-name'\n    tab.name.textContent = object.data.name\n\n    tab.closeBtn = mk('.close-tab-btn', tab)\n    tab.closeBtn.addEventListener('click', (e) => {\n      e.stopPropagation()\n\n      let nextTab\n\n      if (tab === this.activeTab) {\n        const tabs = this.tabsBar.children\n        const tabIndex = Array.from(tabs).indexOf(tab)\n        \n        nextTab = tabIndex > 0 \n          ? tabs[tabIndex - 1]\n          : tabs[tabIndex + 1];\n      }\n \n      this.closeTab(tab)\n      objectManager.closeObject(object, 'tabManager')\n\n      if (nextTab) {\n        this.activateTab(nextTab)\n        this.saveActiveTab(nextTab.getAttribute('object-id'))\n      } else {\n        this.clearActiveTab()\n      }\n    })\n    tab.closeBtn.innerHTML += '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M6 18 18 6M6 6l12 12\"></path></svg>'\n    tab.view = mk('.tab-view', this.tabsView)\n\n    const pre = mk('.object-code', tab.view, 'pre')\n    pre.style.height = window.innerHeight - this.tabsBarHeight + 'px'\n\n    if (object.cutEditor) {\n      const main = await repo.get(repo.mainObjectId)\n\n      const c = main.code\n      const startQuery = '//cut-start ' + object.data.name\n      const endQuery = '//cut-end ' + object.data.name\n\n      const start = c.indexOf(startQuery)\n      const end = c.indexOf(endQuery)\n      if (start && end) {\n        pre.innerText = c.substring(start + startQuery.length, end).trim()\n      }\n      pre.setAttribute('contenteditable', 'true')\n      pre.addEventListener('keyup', async () => {\n        const startPart = c.substring(0, start + startQuery.length)\n        const endPart = c.substring(end)\n        const txt = pre.innerText.trim()\n\n        main.code = startPart + \"\\n\" + txt + \"\\n\" + endPart\n        await repo.set(repo.mainObjectId, main)\n      })\n\n    } else {\n      const editor = monaco.editor.create(pre, {\n        value: object.code,\n        language: 'javascript',\n        theme: 'vs-dark',\n        automaticLayout: true,\n        fontSize: 15\n      })\n      editor.onDidChangeModelContent((e) => {\n        if (!object.id) return\n        \n        const pos = editor.getPosition()\n        objectManager.openObject(object, pos)\n        object.code = editor.getValue()\n\n        repo.set(object.id, object)\n      })\n\n      const openedObjects = objectManager.getOpenedObjects()\n      const pos = openedObjects[object.id]\n      if (pos && typeof pos === 'object') editor.revealPositionInCenter(pos)\n    }\n\n    this.activateTab(tab)\n  },\n  closeTab(tab) {\n    tab.remove()\n    tab.view.remove()\n  },\n  activateTab(tab) {\n    if (this.activeTab) {\n      this.activeTab.classList.remove('active')\n      this.activeTab.view.classList.add('hidden')\n    }\n    tab.classList.add('active')\n    tab.view.classList.remove('hidden')\n    this.activeTab = tab\n  },\n  saveActiveTab(id) {\n    kvRepo.set('activeTabId', id)\n  },\n  clearActiveTab() {\n    kvRepo.del('activeTabId')\n  },\n  async restoreLastActiveTab() {\n    const value = await kvRepo.get('activeTabId')\n    if (!value) return\n\n    const tab = this.tabsBar.querySelector(`[object-id=\"${value}\"]`)\n    if (!tab) return\n    this.activateTab(tab)\n  }\n}\n\nconst tabManagerWidth = `calc(100% - ${obWidth}px)`\n//tabManager.init(app, mk, tabManagerWidth)\n\nconst objectManager = {\n  openedObjectsIds: {},\n\n  async init() {\n    const v = await kvRepo.get('openedObjectsIds')\n    if (v) this.openedObjectsIds = v\n  },\n  getOpenedObjects() {\n    return this.openedObjectsIds\n  },\n  isObjectOpened(objectId) {\n    return Boolean(this.openedObjectsIds[objectId])\n  },\n  openObject(object, pos) {\n    this.openedObjectsIds[object.id] = pos ? pos : 1\n    this.saveOpenedObjects()\n  },\n  closeObject(object) {\n    delete this.openedObjectsIds[object.id]\n    this.saveOpenedObjects()\n  },\n  saveOpenedObjects() {\n    kvRepo.set('openedObjectsIds', this.openedObjectsIds)\n  },\n}\n\nconst renderObject = (object, target, repo) => {\n  const d = mk(object.id, target)\n  d.className = 'object'\n\n  d.name = mk(null, d)\n  d.name.innerText = object.data.name\n  d.name.addEventListener('click', async (e) => {\n    if (objectManager.isObjectOpened(object.id)) return\n    \n    tabManager.openTab(repo, object)\n    tabManager.saveActiveTab(object.id)\n    objectManager.openObject(object)\n  })\n\n  const children = mk(null, d)\n  children.className = 'children'\n\n  return { objectDom: d, children }\n}\n\nconst process = async (repo, cache, targetDiv) => {\n  const objects = await repo.getAll()\n \n  for (let i = 0; i < objects.length; i++) {\n    const o = objects[i]\n    const name = o.data.name\n\n    cache.byId[o.id] = o\n    cache.nameToId[name] = o.id\n    cache.names.push(name)\n\n    if (o.id !== 'sys-main' && o.code) {\n      try {\n        const fn = await createFnFromCode(o.code)\n        //x.s(name, fn)\n      } catch (e) {\n        console.error(e)\n      }\n    }\n  }\n  \n  const sortedNames = cache.names.sort()\n  for (let i = 0; i < sortedNames.length; i++) {\n    \n    const name = sortedNames[i]\n    const id = cache.nameToId[name]\n    const o = cache.byId[id]\n\n    if (objectManager.isObjectOpened(o.id)) {\n      await tabManager.openTab(repo, o)\n    }\n    renderObject(o, targetDiv, repo)\n  }\n}\n\n//await process(sysRepo, sysCache, ob.sysRoot)\n//await process(userRepo, userCache, ob.userRoot)\n//await tabManager.restoreLastActiveTab()\n\n//const mainId = userCache.nameToId['main']\n//if (mainId) await x.x('main', { x })","name":"sys-main"}]}